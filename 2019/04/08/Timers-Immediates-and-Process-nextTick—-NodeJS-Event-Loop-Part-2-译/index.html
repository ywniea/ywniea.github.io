<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Timers, Immediates and Process.nextTick— NodeJS Event Loop Part 2(译) | Ywinea's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Timers, Immediates and Process.nextTick— NodeJS Event Loop Part 2(译)</h1><a id="logo" href="/.">Ywinea's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Timers, Immediates and Process.nextTick— NodeJS Event Loop Part 2(译)</h1><div class="post-meta">Apr 8, 2019<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span></div><div class="post-content"><p>原文：<a href="https://blog.insiderattack.net/timers-immediates-and-process-nexttick-nodejs-event-loop-part-2-2c53fd511bb3" target="_blank" rel="noopener">https://blog.insiderattack.net/timers-immediates-and-process-nexttick-nodejs-event-loop-part-2-2c53fd511bb3</a> 作者：Deepal Jayasekara</p>
<p>前一篇文章讲了NodeJS中Event loop的概要。在这篇文章中，我们会详细的探讨之前提到过的三个非常重要的队列：timers, immediates, process.nextTick回调函数。</p>
<a id="more"></a>

<h3 id="Next-Tick-Queue"><a href="#Next-Tick-Queue" class="headerlink" title="Next Tick Queue"></a>Next Tick Queue</h3><p>还是先看一下之前的那张图。</p>
<p><img src="/media/15767364959198.jpg" alt=""></p>
<p>Next tick queue与其他四个主要的队列是区分开的，因为它不是libuv内部支持的，而是Node自己实现的。</p>
<p>在Event loop的每个阶段之前(timers queue, IO events queue, immediates queue, close handlers queue are the four main phases)，Node就会去检查next tick queue是不是空的。如果next tick queue中不是空的，Node就会立刻去处理队列里面的任务，直到队列为空之前都不会移动到下一个阶段。</p>
<p>这将导致新的问题：用<code>process.nextTick</code>方法不停的向next tick queue中添加event会导致IO和其他队列永久饥饿。看下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNextTickRecurs</span>(<span class="params">count</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (self.id === <span class="literal">undefined</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        self.id = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (self.id === count) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">`process.nextTick call <span class="subst">$&#123;++self.id&#125;</span>`</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        addNextTickRecurs.call(self, count);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">addNextTickRecurs(<span class="literal">Infinity</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>, <span class="string">'omg! setTimeout was called'</span>), <span class="number">10</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>, <span class="string">'omg! setImmediate also was called'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">fs.readFile(__filename, () =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'omg! file read complete callback was called!'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'started'</span>);</span></pre></td></tr></table></figure>

<p>你将会看到输出是一个无限循环的nexttick的回调函数的输出结果， setTimeout, setImmediate 和 fs.readFile的回调函数永远不会被执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">started</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">4</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">5</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">6</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">7</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">8</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">9</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">11</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">process.nextTick call <span class="number">12</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">....</span></pre></td></tr></table></figure>

<blockquote>
<p>在Node v0.12之前有个<code>process.maxTickDepth</code>，开发者可以手动设置它，他作为<code>nextTick queue</code>的长度的上限(门槛threshold)使得Node不会添加超过<code>maxTickDepth</code>的回调到<code>nextTick queue</code>中。但是Node v0.12之后，这个<code>process.maxTickDepth</code>就被移除了，只是不提倡开发者向<code>nextTick queue</code>中不停的添加event。</p>
</blockquote>
<h3 id="Timers-queue"><a href="#Timers-queue" class="headerlink" title="Timers queue"></a>Timers queue</h3><blockquote>
<p>我们之前提到过虽然把他们都叫做queue，但是实际上存放timer的数据结构是一个最小堆min-heap。这个最小堆可以通过libuv去访问。</p>
</blockquote>
<p>当你使用<code>setTimeout</code> 或者<code>setInterval</code>添加timer或者interval到timer heap中，当event loop轮询到了timer queue的阶段，Node就会去检查找出到了时间的<code>timers/intervals</code>然后分别去执行处理他们的回调函数。如果有多个timer的时间都到了，并且他们有相同的<code>expiration period</code>，就是说他们设置的到期时间是一样的。那么就会按照他们设置的先后顺序来执行他们的回调函数。</p>
<p>当一个timer被设置了某个特定的到期时间，并不能保证这个timer的callback一定就会精确的在时间一到就立刻去执行。处理timer的回调函数的时间，要根据系统的执行效率，也要看当前event loop正在哪个阶段。并且Node在处理timer的回调函数之前也会去检查一下这个timer是不是事件到了，这也会占用一部分的CPU时间。</p>
<p>但是，timer设置的<code>expiration period</code>到期时间至少保证了timer的回调函数不会在这段时间之前就执行了。</p>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = process.hrtime();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> end = process.hrtime(start);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">`timeout callback executed after <span class="subst">$&#123;end[<span class="number">0</span>]&#125;</span>s and <span class="subst">$&#123;end[<span class="number">1</span>]<span class="regexp">/Math.pow(10,9)&#125;ms`);</span></span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="string"><span class="subst"><span class="regexp">&#125;, 1000);</span></span></span></span></pre></td></tr></table></figure>
<p>这段代码的本意是设置一个timer，让它在1000ms之后去执行回调函数。这个回调函数会打印出从设置timer到它的回调函数执行，总共花了多少时间。</p>
<p>但是它实际上做的是在1000ms之后将timer的回调函数放到<code>timer heap</code>中。至于这个回调函数什么时候执行，就不能保证了。</p>
<p>试着运行几遍这个函数，每次都会得到不一样的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">timeout callback executed after <span class="number">1</span>s and <span class="number">0.005320755</span>ms</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">timeout callback executed after <span class="number">1</span>s and <span class="number">0.001946333</span>ms</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">timeout callback executed after <span class="number">1</span>s and <span class="number">0.004830446</span>ms</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>
<p>但是永远不会出现这样的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">timeout callback executed after <span class="number">1</span>s and <span class="number">0</span>ms</span></pre></td></tr></table></figure>

<h3 id="Immediates-Queue"><a href="#Immediates-Queue" class="headerlink" title="Immediates Queue"></a>Immediates Queue</h3><p>Immediates queue和timer queue的表现基本上是相似的，但是immediates queue还有一些他自己的特征。不像timer，即使timer的到期时间设置成0，timer也无法保证他的回调函数被立即执行。Immediate可以保证自己的回调函数在IO阶段之后被立即执行。可以像下面这样添加回调函数到immediate queue中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Hi, this is an immediate'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>
<h4 id="setTimeout-vs-setImmediate"><a href="#setTimeout-vs-setImmediate" class="headerlink" title="setTimeout vs setImmediate ?"></a>setTimeout vs setImmediate ?</h4><p>从文章开头的那个图可以看出来，event loop的轮询是从timer queue开始的，然后是I/O queue，在然后才是immediate queue。那么大概可以推断出下面的代码的运行结果，是先打印setTimeout, 然后在打印setImmediate。是这样吗？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>
<p><strong>事实上，这段代码的运行结果是不确定的！</strong></p>
<p>这是因为给一个timer的到期时间设置成0，并不能保证这个timer的回调函数就在0秒之后立即执行。因为event loop在执行这段代码的时候不一定在什么阶段轮询，它不能保证会立刻看到这个到期了的timer。<br>看一下这个例子。这段代码就能保证immediate先打印，然后再打印timeout。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">fs.readFile(__filename, () =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>
<p>看一下这段代码是怎样执行的：</p>
<ul>
<li>首先，用<code>fs.readFile</code>方法异步读取当前文件(__filename)，并且提供一个文件读取完成之后会被触发的回调函数。</li>
<li>event loop就开始了。</li>
<li>当文件读取完成，会将回调函数添加到IO queue里面。</li>
<li>其他的队列里面都是空的，没有可以去处理的event。然后event loop就看到了添加到IO queue里面的这个回调函数。并执行它。</li>
<li>在执行的过程中，一个timer被添加到timer queue，一个immediate 被添加到immediate queue。</li>
<li>因为现在event loop正轮询到了IO queue的阶段，执行完readfile加到IO queue里面的callback之后，IO queue里面就没有别的event了。然后event loop就跳到了下一个阶段immediate queue。然后就发现了immediate queue中由readfile的回调函数添加的setImmediate的回调函数，于是就打印了immediate</li>
<li>在下一个循环的event loop的timer阶段，timer queue就会有已经到期的timer，就打印出了timeout。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>看一下这个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is set immediate 1'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is set immediate 2'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is set immediate 3'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is set timeout 1'</span>), <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is set timeout 2'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is process.nextTick added inside setTimeout'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is set timeout 3'</span>), <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is set timeout 4'</span>), <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is set timeout 5'</span>), <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is process.nextTick 1'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    process.nextTick(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>, <span class="string">'this is the inner next tick inside next tick'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is process.nextTick 2'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is process.nextTick 3'</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is process.nextTick 4'</span>));</span></pre></td></tr></table></figure>
<p>上面代码执行完之后，下面的event会被添加到各自的event queue中：</p>
<ul>
<li>3 immediates</li>
<li>5 timer callbacks</li>
<li>5 next tick callbacks</li>
</ul>
<p>然后看一下他怎么执行：</p>
<ul>
<li>event loop开始轮询。event loop检查两个中间队列，发现next tick queue不为空，于是去执行next tick queue中的event。</li>
<li>在执行到第二个next tick callback的时候又将一个新的next tick callback 添加到了next tick queue的队尾。一直执行next tick callback中的event，直到清空next tick queue。</li>
<li>然后event loop到了timer queue，执行了5个timer queue中的event。在执行第5个timer的callback的时候，又添加了一个next tick callback到next tick queue中。</li>
<li>在清空了timer queue之后，跳到下个阶段（IO queue）之前，再次检查两个中间队列intermediate queues，发现next tick queue不为空，于是去执行next tick queue中的callback，直到清空next tick queue。</li>
<li>event loop轮询到了下个阶段 IO queue。IO queue里面是空的。再次检查发现两个中间队列intermediate queues都是空的，就直接跳到下个阶段immediates queue。</li>
<li>执行immediates queue中的三个回调函数。</li>
</ul>
<p>因此执行结果为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is process.nextTick <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is process.nextTick <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is process.nextTick <span class="number">3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is process.nextTick <span class="number">4</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is the inner next tick inside next tick</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is <span class="keyword">set</span> timeout 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">this is <span class="keyword">set</span> timeout 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">this is <span class="keyword">set</span> timeout 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">this is <span class="keyword">set</span> timeout 4</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">this is <span class="keyword">set</span> timeout 5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">this is process.nextTick added inside setTimeout</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">this is <span class="keyword">set</span> immediate 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">this is <span class="keyword">set</span> immediate 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">this is <span class="keyword">set</span> immediate 3</span></pre></td></tr></table></figure>


</div><div class="tags"><a href="/tags/Node-js/">Node.js</a></div><div class="post-nav"><a class="pre" href="/2019/04/10/Promises-Next-Ticks-and-Immediates%E2%80%94-NodeJS-Event-Loop-Part-3-%E8%AF%91/">Promises, Next-Ticks, and Immediates— NodeJS Event Loop Part 3(译)</a><a class="next" href="/2019/04/07/Event%20Loop%20and%20the%20Big%20Picture%20%E2%80%94%20NodeJS%20Event%20Loop%20Part%201%EF%BC%88%E8%AF%91)/">Event Loop and the Big Picture — NodeJS Event Loop Part 1（译）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://github.com/ywniea"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%B0%E6%9E%9C/">冰果</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Flex/" style="font-size: 15px;">Flex</a> <a href="/tags/Other/" style="font-size: 15px;">Other</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/%E5%86%B0%E6%9E%9C/" style="font-size: 15px;">冰果</a> <a href="/tags/Grid/" style="font-size: 15px;">Grid</a> <a href="/tags/React-lifecycle/" style="font-size: 15px;">React lifecycle</a> <a href="/tags/React-memo/" style="font-size: 15px;">React memo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/03/%E3%80%8C%E9%9D%9E%E5%81%9A%E4%B8%8D%E5%8F%AF%E7%9A%84%E4%BA%8B%E5%B0%B1%E5%B0%BD%E5%BF%AB%E8%A7%A3%E5%86%B3%E3%80%8D/">「非做不可的事就尽快解决」</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/05/Grid%E5%B8%83%E5%B1%80/">Grid布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/15/New-Changes-to-the-Timers-and-Microtasks-in-Node-v11-0-0-and-above-%EF%BC%88%E8%AF%91%EF%BC%89/">New Changes to the Timers and Microtasks in Node v11.0.0 (and above) Part 6（译）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/12/Event-Loop-Best-Practices-%E2%80%94-NodeJS-Event-Loop-Part-5%EF%BC%88%E8%AF%91%EF%BC%89/">Event Loop Best Practices — NodeJS Event Loop Part 5（译）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/Handling-IO-%E2%80%94-NodeJS-Event-Loop-Part-4-%E8%AF%91/">Handling IO — NodeJS Event Loop Part 4(译)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Promises-Next-Ticks-and-Immediates%E2%80%94-NodeJS-Event-Loop-Part-3-%E8%AF%91/">Promises, Next-Ticks, and Immediates— NodeJS Event Loop Part 3(译)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/08/Timers-Immediates-and-Process-nextTick%E2%80%94-NodeJS-Event-Loop-Part-2-%E8%AF%91/">Timers, Immediates and Process.nextTick— NodeJS Event Loop Part 2(译)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/07/Event%20Loop%20and%20the%20Big%20Picture%20%E2%80%94%20NodeJS%20Event%20Loop%20Part%201%EF%BC%88%E8%AF%91)/">Event Loop and the Big Picture — NodeJS Event Loop Part 1（译）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/11/throttle-and-debounce/">throttle and debounce</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/15/%E7%BB%A7%E6%89%BF-vs-%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/">继承 vs 行为委托</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.github.com/ywniea" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Ywinea's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
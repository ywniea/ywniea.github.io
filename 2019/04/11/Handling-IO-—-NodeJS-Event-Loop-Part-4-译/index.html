<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Handling IO — NodeJS Event Loop Part 4(译) | Ywinea's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Handling IO — NodeJS Event Loop Part 4(译)</h1><a id="logo" href="/.">Ywinea's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Handling IO — NodeJS Event Loop Part 4(译)</h1><div class="post-meta">Apr 11, 2019<span> | </span><span class="category"><a href="/categories/JavaScript/">JavaScript</a></span></div><div class="post-content"><p>原文：<a href="https://blog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1" target="_blank" rel="noopener">https://blog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1</a> 作者：Deepal Jayasekara</p>
<p>这篇文章将详细介绍NodeJS中是怎样处理IO请求的。希望能够深挖event loop是怎样实现的，也会研究IO请求是怎样与其他异步操作相结合的。</p>
<a id="more"></a>

<h3 id="Async-I-O"><a href="#Async-I-O" class="headerlink" title="Async I/O"></a>Async I/O</h3><p>在所有的操作系统的实现中，都会为异步IO提供事件通知接口。NodeJS利用这些平台级事件通知系统来提供非阻塞的异步IO。</p>
<p>正如我们所看到的，NodeJS是一个实用程序的集合，这些实用程序最终被聚合到高性能的NodeJS框架中。他们有：</p>
<ul>
<li>Chrome v8 engine — For high-performance JavaScript evaluation</li>
<li>Libuv — For Event Loop with Asynchronous I/O</li>
<li>c-ares — For DNS Operations</li>
<li>other add-ons such as (http-parser, crypto and zlib)</li>
</ul>
<p><img src="/media/15767718602235.jpg" alt=""><br>Diagram1</p>
<p>这篇文章我们会讨论libuv是怎样为Node提供异步IO。</p>
<p><img src="/media/15767718814754.jpg" alt=""><br>Diagram2: The Event Loop in a nutshell</p>
<p>总结一下目前为止我们所知的event loop：</p>
<ul>
<li>event loop会从处理所有的已经到时间的timer的callback开始执行。</li>
<li>然后它会去处理任何挂起的IO操作，并会有选择的等待一些挂起的IO完成</li>
<li>然后它会去处理setImmediate的callback函数</li>
<li>最后，它会处理任何IO close queue中的handler。</li>
<li>在每个阶段之间，libuv需要将现阶段的结果与高层的Node架构（这里指的是JavaScript）进行交互。在每次交互的时候，任何<code>process.nextTick</code>的callback或者是其他的microtask的callback都会被处理、执行。</li>
</ul>
<p>现在来看NodeJS中event loop的IO 请求。</p>
<blockquote>
<p><strong>什么是IO？</strong><br>一般来说，除了CPU以外，与其他任何设备进行交互都叫做IO。例如文件系统的操作、TCP/UDP的网络操作。</p>
</blockquote>
<h3 id="Libuv-and-NodeJS-I-O"><a href="#Libuv-and-NodeJS-I-O" class="headerlink" title="Libuv and NodeJS I/O"></a>Libuv and NodeJS I/O</h3><p>JavaScript自己无法实现异步IO操作。因此在开发NodeJS的过程中，libuv最初是为Node提供异步I/O的。但是目前libuv作为一个独立的库，甚至可以单独使用。libuv在NodeJS的体系结构中的作用，就是抽象内部IO的复杂性，并为上层的Node提供一个接口，这样Node就可以执行与平台无关的异步I/O，而不用去担心它到底运行在哪个平台上。</p>
<p>我们知道libuv处于分层架构的较低层，现在来看一下高层的NodeJS与libuv的event loop的各个阶段之间的关系。</p>
<p><img src="/media/15767719066323.jpg" alt=""><br>Diagram3: Event loop and JavaScript</p>
<p>从前面一张event loop图中我们直到event loop有四个可以区分开来的阶段。但是在libuv中，有7个阶段：</p>
<ol>
<li>Timers — 调用由setTimeout和setInterval设置的到期的timer回调和间隔回调函数。</li>
<li>Pending I/O callbacks — 此处执行的任何已完成/出错的I/O操作的挂起回调。Pending Callbacks of any completed/errored I/O operation to be executed here.</li>
<li>Idle handlers — 执行一些libuv内部操作</li>
<li>Prepare Handlers — 在轮询I/O之前执行一些准备工作。</li>
<li>I/O Poll — 可选地等待任何I/O完成。</li>
<li>Check handlers — 在轮询I/O后执行一些事后工作。通常，此处将调用由setImmediate安排的回调。</li>
<li>Close handlers — 对任何关闭的I/O操作（关闭接口连接等）执行关闭处理程序</li>
</ol>
<p>现在有两个问题：</p>
<ol>
<li>什么是Check handlers？</li>
<li>什么是I/O Polling？为什么我们在执行完completed I/O的callback之后，为了I/O轮询而阻塞Node？Node不是非阻塞的吗？</li>
</ol>
<p>接下来回答这两个问题。</p>
<h4 id="Check-Handlers"><a href="#Check-Handlers" class="headerlink" title="Check Handlers"></a>Check Handlers</h4><p>当NodeJS初始化的时候，在libuv中会把那些将要被注册的<code>setImmediate</code>的回调函数作为check handler。这实际上就是说，用<code>setImmidiate</code>注册的任何回调函数最终都会放到libuv的check handler queue中。在event loop中，可以保证这个队列在I/O操作之后执行。</p>
<h4 id="I-O-Polling"><a href="#I-O-Polling" class="headerlink" title="I/O Polling"></a>I/O Polling</h4><p>I/O Polling到底是什么？尽管在图event loop中我把I/O callbacks queue和I/O polling合并成了一个阶段，I/O Polling发生在消费完completed/errored I/O 的callbacks之后。</p>
<p>但是，I/O Polling是可选的。 I/O Polling会不会发生取决于一些特定的条件。先看一下libuv中是怎样实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">r = uv__loop_alive(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    uv__update_time(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    uv__update_time(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    uv__run_timers(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ran_pending = uv__run_pending(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    uv__run_idle(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    uv__run_prepare(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    timeout = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      timeout = uv_backend_timeout(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    uv__io_poll(loop, timeout);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    uv__run_check(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    uv__run_closing_handles(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">      uv__update_time(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">      uv__run_timers(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    r = uv__loop_alive(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面这段代码是<code>uv_run</code>方法的一小节，位于libuv源代码的<code>core.c</code>文件中。这是NodeJS的核心部分。</p>
<p>对照上面的第三张图看一下：</p>
<ol>
<li><code>uv__loop_alive</code> — 检查是不是有任何需要处理的handlers或者是挂起的操作。就是检查一下是不是需要继续运行event loop。</li>
<li><code>uv__update_time</code> — 这个方法会发起一个系统请求来获取当前时间并且更新轮询的时间。这个方法可以确定是不是有到期的timer需要处理。</li>
<li><code>uv__run_timers</code> — 运行所有到期的timer的callback。</li>
<li><code>uv__run_pending</code> — 运行所有的completed/errored I/O 的callbacks。</li>
<li><code>uv__io_poll</code> — I/O 轮询。</li>
<li><code>uv__run_check</code> — 运行所有的 check handlers。setImmediate 的callbacks会在这里运行。</li>
<li><code>uv__run_closing_handles</code> — 运行所有的close handlers。</li>
</ol>
<p>首先，event loop会通过调用<code>uv__loop_alive</code>方法检查是不是还需要轮询，返回值是布尔值。如果有下面的情况就会返回true，表示需要轮询：</p>
<ul>
<li>There are active handles to be invoked,</li>
<li>There are active requests (active operations) pending</li>
<li>There are any closing handlers to be invoked</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__loop_alive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> uv__has_active_handles(loop) ||</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">         uv__has_active_reqs(loop) ||</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">         loop-&gt;closing_handles != <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>只要<code>uv__loop_alive</code>方法返回true，event loop就会一直运行。</p>
<p>在处理完所有到期的timer的callback之后，就会调用<code>uv__run_pending</code>方法。这个方法会遍历libuv事件中存储在<code>pending_queue</code>里面的所有的已完成的I/O操作。如果队列<code>pending_queue</code>为空，这个方法会返回0，否则，<code>pending_queue</code>队列里面的回调函数都会被处理掉，并且这个方法返回1.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uv__run_pending</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  QUEUE* q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  QUEUE pq;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uv__io_t</span>* w;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  QUEUE_MOVE(&amp;loop-&gt;pending_queue, &amp;pq);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span> (!QUEUE_EMPTY(&amp;pq)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    q = QUEUE_HEAD(&amp;pq);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    QUEUE_REMOVE(q);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    QUEUE_INIT(q);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    w = QUEUE_DATA(q, <span class="keyword">uv__io_t</span>, pending_queue);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    w-&gt;cb(loop, w, POLLOUT);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>现在来看一下<code>uv__io_poll</code>方法。I/O轮询就是在这个方法里面执行的。这个方法接受的第二个参数timeout是由方法<code>uv_backend_timeout</code>计算出来的。<code>uv__io_poll</code>用timeout这个参数来决定它到底应该为I/O轮询阻塞多久。如果timeout=0，event loop就会跳过I/O轮询直接到下一步，去check handlers，就是setImmediate的阶段。到底是什么因素决定了<code>timeout</code>的值？根据<code>uv_run</code>的代码我们可以推断：</p>
<ul>
<li>如果event loop是处于<code>UV_RUN_DEFAULT</code>模式，<code>timeout</code>是由<code>uv_backend_timeout</code>方法计算得到的。</li>
<li>如果event loop是处于<code>UV_RUN_ONCE</code>模式，并且<code>uv_run_pending</code>方法返回0（例如pending_queue是空的）<code>timeout</code>是由<code>uv_backend_timeout</code>方法计算得到的。</li>
<li>其他情况，timeout是0</li>
</ul>
<blockquote>
<p>现阶段先不要太纠结event loop的不同模式，像是<code>UV_RUN_DEFAULT</code>或者<code>UV_RUN_ONCE</code>等。</p>
</blockquote>
<p>现在我们来看一下<code>uv_backend_timeout</code>方法是怎样计算<code>timeout</code>的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_backend_timeout</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!uv__has_active_handles(loop) &amp;&amp; !uv__has_active_reqs(loop))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;loop-&gt;idle_handles))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!QUEUE_EMPTY(&amp;loop-&gt;pending_queue))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (loop-&gt;closing_handles)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> uv__next_timeout(loop);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li>如果event loop的<code>stop_flag</code>设置好了，说明event loop将要退出了，timeout就是0</li>
<li>如果没有需要处理的handlers或者挂起的操作，就不需要等待，timeout就是0</li>
<li>如果有挂起的idle handles需要处理，就不应该等待I/O轮询，timeout就是0</li>
<li>如果<code>pending_queue</code>中有completed I/O handlers，就不应该等待I/O轮询，timeout就是0</li>
<li>如果有挂起的close handlers，就不应该等待I/O轮询，timeout就是0</li>
</ul>
<p>如果以上情况都不是，就有方法<code>uv__next_timeout</code>来决定libuv需要等待I/O轮询多长时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv__next_timeout</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uv_loop_t</span>* loop)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">heap_node</span>* <span class="title">heap_node</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> <span class="keyword">uv_timer_t</span>* handle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint64_t</span> diff;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  heap_node = heap_min((<span class="keyword">const</span> struct heap*) &amp;loop-&gt;timer_heap);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (heap_node == <span class="literal">NULL</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* block indefinitely */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  handle = container_of(heap_node, <span class="keyword">uv_timer_t</span>, heap_node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (handle-&gt;timeout &lt;= loop-&gt;time)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  diff = handle-&gt;timeout - loop-&gt;time;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (diff &gt; INT_MAX)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    diff = INT_MAX;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> diff;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>uv__next_timeout</code>会返回最近的一个定时器的值。如果没有定时器，就返回-1，来表示无限大。</p>
<p>现在我们知道了「为什么我们在执行完completed I/O callback之后，为了I/O轮询阻塞Node？Node不应该是非阻塞的吗？」这个问题的答案。</p>
<p><strong>如果有任何挂起的任务需要被处理的话，event loop不会被阻塞住。</strong> 如果没有任何挂起的task需要被处理，在计时器到期之前，event loop才会被阻塞。一旦计时器到期，event loop又会被激活重新开始轮询。</p>
<p>现在我们知道了event loop会等待I/O多久。这个timeout的值会被传给<code>uv__io_poll</code>方法，这个方法会处理timeout到期内的任何I/O操作，或者是等到系统特定的安全的timeout阈值。总之，到了时间之后，event loop又会重新被激活，轮询到下一个<code>check handlers</code>阶段。</p>
<p>I/O轮询在不同的操作系统中是不一样的。在Linux中是epoll_wait， macOS是kqueue，windows中是IOCP(Input Output Completion Port)的<code>GetQueuedCompletionStatus</code>。I/O轮询实际上是非常复杂的，在这系列的文章中不会深究。</p>
<h4 id="关于ThreadPool"><a href="#关于ThreadPool" class="headerlink" title="关于ThreadPool"></a>关于ThreadPool</h4><p>ThreadPool基本上是用于执行文件I/O操作。DNS操作中的<code>getaddrinfo</code>和<code>getnameinfo</code>调用仅仅是因为在不同的平台中I/O是很复杂的。由于Thread Pool的大小是有限制的（默认是4），对文件系统的多个请求就可能会阻塞，直到等到一个线程空闲出来才能重新开始工作。然而，我们可以用环境变量<code>UV_THREADPOOL_SIZE</code>来提升Thread pool的的大小，从而提高系统的性能。</p>
<p>但是这种固定大小的的Thread Pool仍然是NodeJS的瓶颈。因为Thread Pool不仅仅会执行文件I/O、<code>getaddrinfo</code>、<code>getnameinfo</code>等这些操作，某些CPU密集型的加密操作（如randomBytes、randomFill和pbkdf2）也在libuv线程池上运行，以防止对应用程序性能产生任何不利影响，但这也使可用线程成为I/O操作的一种甚至稀缺的资源。</p>
<p>有个提议是根据负载把线程池变成可调节大小的，但这一提议被否决了，原因是为了将来便于引入一种可插入线程的API。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章仔细介绍了NodeJS中的I/O操作，深挖了libuv的源代码。我们知道了libuv中的event loop分为7个阶段。其中I/O polling会阻塞event loop，但是并不是说NodeJS就是阻塞的。I/O polling的timeout到底会阻塞event loop多久，event loop什么时候会重新被激活重新轮询，这取决于有没有pending tasks to be executed。只要有需要event loop去处理的task，就不会等待I/O。</p>
</div><div class="tags"><a href="/tags/Node-js/">Node.js</a></div><div class="post-nav"><a class="pre" href="/2019/05/05/Grid%E5%B8%83%E5%B1%80/">Grid布局</a><a class="next" href="/2019/04/10/Promises-Next-Ticks-and-Immediates%E2%80%94-NodeJS-Event-Loop-Part-3-%E8%AF%91/">Promises, Next-Ticks, and Immediates— NodeJS Event Loop Part 3(译)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://github.com/ywniea"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%B0%E6%9E%9C/">冰果</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Flex/" style="font-size: 15px;">Flex</a> <a href="/tags/Other/" style="font-size: 15px;">Other</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/%E5%86%B0%E6%9E%9C/" style="font-size: 15px;">冰果</a> <a href="/tags/Grid/" style="font-size: 15px;">Grid</a> <a href="/tags/React-lifecycle/" style="font-size: 15px;">React lifecycle</a> <a href="/tags/React-memo/" style="font-size: 15px;">React memo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/03/%E3%80%8C%E9%9D%9E%E5%81%9A%E4%B8%8D%E5%8F%AF%E7%9A%84%E4%BA%8B%E5%B0%B1%E5%B0%BD%E5%BF%AB%E8%A7%A3%E5%86%B3%E3%80%8D/">「非做不可的事就尽快解决」</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/05/Grid%E5%B8%83%E5%B1%80/">Grid布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/Handling-IO-%E2%80%94-NodeJS-Event-Loop-Part-4-%E8%AF%91/">Handling IO — NodeJS Event Loop Part 4(译)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Promises-Next-Ticks-and-Immediates%E2%80%94-NodeJS-Event-Loop-Part-3-%E8%AF%91/">Promises, Next-Ticks, and Immediates— NodeJS Event Loop Part 3(译)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/08/Timers-Immediates-and-Process-nextTick%E2%80%94-NodeJS-Event-Loop-Part-2-%E8%AF%91/">Timers, Immediates and Process.nextTick— NodeJS Event Loop Part 2(译)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/07/Event%20Loop%20and%20the%20Big%20Picture%20%E2%80%94%20NodeJS%20Event%20Loop%20Part%201%EF%BC%88%E8%AF%91)/">Event Loop and the Big Picture — NodeJS Event Loop Part 1（译）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/11/throttle-and-debounce/">throttle and debounce</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/15/%E7%BB%A7%E6%89%BF-vs-%E8%A1%8C%E4%B8%BA%E5%A7%94%E6%89%98/">继承 vs 行为委托</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/09/this-in-JS/">this in JS</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/Deep-clone-in-JS/">Deep clone in JS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.github.com/ywniea" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Ywinea's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
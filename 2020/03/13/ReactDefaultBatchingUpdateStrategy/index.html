<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>React批量更新策略 ReactDefaultBatchingStrategy | Ywinea's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">React批量更新策略 ReactDefaultBatchingStrategy</h1><a id="logo" href="/.">Ywinea's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">React批量更新策略 ReactDefaultBatchingStrategy</h1><div class="post-meta">Mar 13, 2020<span> | </span><span class="category"><a href="/categories/React/">React</a></span></div><div class="post-content"><p>React 有一个默认的批量更新策略，在我们进行组件更新的时候就会运行这个更新策略，它决定了组件是何时进行更新的。</p>
<p>我们在使用setState的时候可能会有一些困惑：为什么setState有时是同步的，有时又是异步的？<br>例如：</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">super</span>(props);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">this</span>.state = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);    <span class="comment">// 第 1 次 log</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);    <span class="comment">// 第 2 次 log</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">		setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);  <span class="comment">// 第 3 次 log</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span> &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);  <span class="comment">// 第 4 次 log</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">		&#125;, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr></table></figure>

<p>上面结果是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span></pre></td></tr></table></figure>

<p>原来在React组件在更新的时候，（例如setState），React的批量更新策略（ReactDefaultBatchingStrategy）会根据当前是否处于批量更新中（isBatchingUpdate）去做出不同的决策。</p>
<p>如果正处于批量更新中，就把当前component instance放到dirtyComponent队列中去。等待更新。当当前这次更新结束之后回去检查dirtyComponent中是否有新的component添加进来（根据dirtyComponent的length属性是不是有变化），如果有就执行更新操作。</p>
<p>如果不处于批量更新中，那么就会立刻执行更新操作（实际上也是将当前component加入到dirtyComponent数组中，然后立刻进行数组遍历执行 componentUpdate），通过diff 和 patch 找出需要更新的地方并将他们更新到真实的节点上面去。</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>先说事务：事务就是将需要执行的方法使用 wrapper 封装起来，再通过事务提供的 perform 方法执行。 而在 perform 之前，先执行所有 wrapper 中的 initialize 方法，执行完 perform 之后(即执行 method 方法后)再执行所有的 close 方法。一组 initialize 及 close 方法称为一个 wrapper。</p>
<p><img src="/media/15909995132307.jpg" alt="-w630"></p>
<p>下面是一个简单使用事务的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Transaction = <span class="built_in">require</span>(<span class="string">'./Transaction'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们自己定义的事务</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyTransaction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(MyTransaction.prototype, </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Transaction.Mixin, &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> [&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">console</span>.log(<span class="string">'before method perform'</span>); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">console</span>.log(<span class="string">'after method perform'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> MyTransaction();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'test'</span>); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">transaction.perform(testMethod);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印的结果如下:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// before method perform // test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// after method perform</span></span></pre></td></tr></table></figure>

<p>在 ReactDefaultBatchingStrategy 执行过程中用到了事务。</p>
<p>下面这张图是React在调用setState时的执行过程：</p>
<p><img src="/media/15909995323174.jpg" alt="-w833"></p>
<p>我们可以知道 React在执行批量更新策略的时候是这样做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1. isBatchingUpdate &#x3D; true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">2. length1 &#x3D; dirtyComponents.length</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">3. 遍历dirtycomponents 中的组件，依次去判断它是否需要更新。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    如果需要，则走 updateComponent的过程。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    如果不需要更新，则跳过这个组件，再去看下一个组件。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">4. length2 &#x3D; dirtyComponent.length</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">5. 如果length1 &#x3D;&#x3D;&#x3D; length2，那么跳到第6步。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">   如果不相等，将dirtycomponents 中已经更新过了的组件移除掉，跳到第2步，进行下一轮批量更新。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">6. isBatchingUpdate &#x3D; false 批量更新结束</span></pre></td></tr></table></figure>

<p>因此在进行setState时，如果发现正在批量更新，那么当前组件会在下一轮批量更新的时候才去更新。因此我们执行同步代码<code>console.log(this.state.value)</code>的时候会发现 value 没有变化。</p>
<p>但是在 setTimeout 中去执行callback函数里面的 setState 时，说明当前主线程都开始执行 setTimeout 的回调函数了，那么肯定没有同步任务正在执行（React的批量更新算法是同步代码，不是异步代码），也就是说React肯定不处于批量更新的状态，那么setState是立即执行的。</p>
<h2 id="问题：为什么更新前后去获取dirtyComponents的长度，如果有新组件添加进来再去循环更新，而不是直接在更新的过程中找到dirtyComponents新添加进来的元素直接更新？"><a href="#问题：为什么更新前后去获取dirtyComponents的长度，如果有新组件添加进来再去循环更新，而不是直接在更新的过程中找到dirtyComponents新添加进来的元素直接更新？" class="headerlink" title="问题：为什么更新前后去获取dirtyComponents的长度，如果有新组件添加进来再去循环更新，而不是直接在更新的过程中找到dirtyComponents新添加进来的元素直接更新？"></a>问题：为什么更新前后去获取dirtyComponents的长度，如果有新组件添加进来再去循环更新，而不是直接在更新的过程中找到dirtyComponents新添加进来的元素直接更新？</h2><p>因为每次批量更新前，会对dirtyComponent的组件按照mountOrder排序。mountOrder是在渲染组件的过程中给组件添加的顺序，父组件的mountOrder要比子组件的mountOrder要小。<br>在更新的过程中，父子组件的生命周期肯定是这样的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &lt;Child/&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="regexp">/Parent&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Parent componentWillUpdate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Parent render</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Child componentWillUpdate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    Child render</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    Child componentDidUpdate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Parent componentDidUpdate</span></pre></td></tr></table></figure>
<p>按照mountOrder排过序之后再进行update就可以保证生命周期函数的按序执行。</p>
<p>举个例子，假设 <code>Parent</code> 的 <code>mountOrder</code> 是 <code>3</code>， <code>Child</code> 的 <code>mountOrder</code> 是<code>10</code>，进入<code>dirtyComponent</code>中的顺序是 <code>[10, 3]</code> 那么不排序的时候，他们的更新过程是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// mountOrder = 10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Child componentWillUpdate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Child render</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Child componentDidUpdate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// mountOrder = 3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Parent componentWillUpdate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Parent render  <span class="comment">// 发现Child已经更新过了，不需要更新</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">Parent componentDidUpdate</span></pre></td></tr></table></figure>
<p>那么排序之后就是这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// mountOrder = 3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Parent componentWillUpdate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Parent render  <span class="comment">// 发现Child需要更新</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    Child componentWillUpdate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    Child render</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    Child componentDidUpdate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Parent componentDidUpdate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轮到mountOrder = 10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">Child已经更新过了，不满足更新条件。</span></pre></td></tr></table></figure>

</div><div class="tags"><a href="/tags/ReactDefaultBatchingStrategy/">ReactDefaultBatchingStrategy</a></div><div class="post-nav"><a class="next" href="/2019/06/21/Reflow-Repaint/">Reflow &amp; Repaint</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://github.com/ywniea"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Browser/">Browser</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%B0%E6%9E%9C/">冰果</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%8C%E8%AF%8D/">歌词</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/%E5%86%B0%E6%9E%9C/" style="font-size: 15px;">冰果</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Flex/" style="font-size: 15px;">Flex</a> <a href="/tags/Other/" style="font-size: 15px;">Other</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/ReactDefaultBatchingStrategy/" style="font-size: 15px;">ReactDefaultBatchingStrategy</a> <a href="/tags/%E5%AE%AB%E5%B4%8E%E9%AA%8F/" style="font-size: 15px;">宫崎骏</a> <a href="/tags/Grid/" style="font-size: 15px;">Grid</a> <a href="/tags/React-lifecycle/" style="font-size: 15px;">React lifecycle</a> <a href="/tags/Reflow/" style="font-size: 15px;">Reflow</a> <a href="/tags/Repaint/" style="font-size: 15px;">Repaint</a> <a href="/tags/React-memo/" style="font-size: 15px;">React memo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/ReactDefaultBatchingUpdateStrategy/">React批量更新策略 ReactDefaultBatchingStrategy</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/21/Reflow-Repaint/">Reflow & Repaint</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/05/Grid%E5%B8%83%E5%B1%80/">Grid布局</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/15/New-Changes-to-the-Timers-and-Microtasks-in-Node-v11-0-0-and-above-%EF%BC%88%E8%AF%91%EF%BC%89/">New Changes to the Timers and Microtasks in Node v11.0.0 (and above) Part 6（译）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/12/Event-Loop-Best-Practices-%E2%80%94-NodeJS-Event-Loop-Part-5%EF%BC%88%E8%AF%91%EF%BC%89/">Event Loop Best Practices — NodeJS Event Loop Part 5（译）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/Handling-IO-%E2%80%94-NodeJS-Event-Loop-Part-4-%E8%AF%91/">Handling IO — NodeJS Event Loop Part 4(译)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/10/Promises-Next-Ticks-and-Immediates%E2%80%94-NodeJS-Event-Loop-Part-3-%E8%AF%91/">Promises, Next-Ticks, and Immediates— NodeJS Event Loop Part 3(译)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/08/Timers-Immediates-and-Process-nextTick%E2%80%94-NodeJS-Event-Loop-Part-2-%E8%AF%91/">Timers, Immediates and Process.nextTick— NodeJS Event Loop Part 2(译)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/07/Event%20Loop%20and%20the%20Big%20Picture%20%E2%80%94%20NodeJS%20Event%20Loop%20Part%201%EF%BC%88%E8%AF%91)/">Event Loop and the Big Picture — NodeJS Event Loop Part 1（译）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/11/throttle-and-debounce/">throttle and debounce</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://www.github.com/ywniea" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Ywinea's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>